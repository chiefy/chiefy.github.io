<!DOCTYPE html>
<html lang="en">

<head>
	<title>throw new Error(&#39;chief&#39;) - Easily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III</title>
	<meta name="twitter:card" content="javascript, devops, golang and other techno-babble." />
	<meta name="twitter:site" content="@tehsuck" />
	<meta name="twitter:title" content="throw new Error(&#39;chief&#39;) - Easily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III" />
	<meta name="twitter:description" content="Among the many players in the continious integration SaaS providers, I recently discovered Wercker:">
	<meta name="description" content="Among the many players in the continious integration SaaS providers, I recently discovered Wercker:">
	<link rel="canonical" href="https://chiefy.github.io/easily-deploy-a-seneca-microservice-to-ecs-with-wercker-and-terraform-part-iii">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
	<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>

	<link rel="stylesheet" href="/assets/core.css">
	<link rel="stylesheet" href="/assets/gists.css">
	<link rel="stylesheet" href="/assets/rrssb.css">

	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/zenburn.min.css">
	<link rel="alternate" type="application/atom+xml" title="throw new Error(&#39;chief&#39;)" href="https://chiefy.github.io/feed.xml" />

</head>

<body>
	<aside class="logo">
		<a class="social" id="twitter" href="https://twitter.com/tehsuck"><img src="/assets/img/twitter-square-black.png"></a>
		<a class="social" id="instagram" href="https://instagram.com/tehsuck"><img src="/assets/img/instagram-square-black.png"></a>
		<a href="https://chiefy.github.io">
			<img src="http://www.gravatar.com/avatar/adca7d78e74745d1488f59bd3830418e.png?s=80" class="gravatar">
		</a>
		<span class="logo-prompt">hi, i&#39;m chief</span>
		<a class="social" id="github" href="https://github.com/chiefy"><img src="/assets/img/github-square-black.png"></a>
		<a class="social" id="linkedin" href="https://www.linkedin.com/in/chief"><img src="/assets/img/linkedin-square-black.png"></a>
	</aside>

	<main>

		<article>
			<div class="center">
				<h1>Easily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III</h1>
				<time>March 6th, 2016</time>
			</div>
			<div class="divider"></div>
			<p>Among the many players in the continious integration SaaS providers, I recently discovered Wercker:</p>
			<blockquote>
				<p>Build apps faster. Release often. Automate all the things.</p>
			</blockquote>
			<p>The following is the third of a three-part tutorial on how to use Wercker along with Hashicorp&#39;s Terraform and AWS Elastic Container Service (ECS) to easily
				deploy minimal docker services. If you haven&#39;t, please start with <a href="/easily-deploy-a-seneca-microservice-to-ecs-with-wercker-and-terraform-part-i/">the first installment</a>				and then continue here.</p>
			<p>This is the final step in our deployment chain. In the previous parts of this tutorial, we have learned how to use Wercker&#39;s <code>yaml</code> configuration
				to orchestrate a local development environment, create a build artifact with the <em>build</em> pipeline and push our artifact as a docker image to DockerHub.</p>
			<h1 id="creating-an-ecs-cluster-with-terraform">Creating an ECS Cluster With Terraform</h1>
			<p>As previously stated, we will be creating real, live, money-costing AWS infrastructure. You will need a valid AWS keypair which has &quot;PowerUser&quot; rights.
				Once again, unless you want to be charged hourly fees, you must destroy any resources you create with this tutorial. Fortunately <a href="https://www.terraform.io/">Terraform</a>				from <a href="https://www.hashicorp.com/">Hashicorp</a> makes this all very, very easy.</p>
			<p>In order to deploy docker containers to AWS with Wercker, we need to stand up and provision an AWS ECS cluster. The cloned project contains a submodule <code>terraform/ecs</code>				which is a <a href="https://github.com/Capgemini/terraform-amazon-ecs">fork of terraform-amazon-ecs</a>.</p>
			<p>If you don&#39;t already, make sure to setup an <code>awscli</code> profile with your credentials:</p>
			<pre><code>$ aws configure --profile my_personal_profile
AWS Access Key ID [None]: ABCDEFGH1234567
AWS Secret Access Key [None]: ABCDEFGH1234567ABCDEFGH1234567
Default region name [None]: us-east-1
Default output format [None]: json
</code></pre>
			<p>Open and edit <code>terraform/ecs/terraform.tfvars</code> this file is a simple key-value file for setting terraform variables. You will need to provide a public
				key, you should have the private key for SSH access to any EC2 resources created. You will also provide your DockerHub credentials in order for ECS to pull private
				docker images.</p>
			<pre><code># The AWS region you are deploying to
region=&quot;us-east-1&quot;

# The AWS profile you created above with your &quot;PowerUser&quot; keys
aws_profile_name=&quot;personal&quot;

# Absolute path of AWS creds file, defaults to ~/.aws/credentials
aws_creds_file=&quot;/Users/chief/.aws/credentials&quot;

# DockerHub auth which can be found at ~/.docker/config.json
dockerhub_auth=&quot;YLDOkjd2lad0lkeenkeo$#23==&quot;
dockerhub_email=&quot;chief@beefdisciple.com&quot;

# Public SSH key
public_key=&quot;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAqtYxLvMCPCujceL9GeR7SHHtHODKh+WLt5jPXcaIAnXGO0OlQAaZEHIVlHvytxRvg/cgqS6r3i/pnz8thLrpLFjBdYW0LtMK1z2U8s3qXxszksf6McJa4ffedWj6N6B1fziP4DL4KwjhoslcHyfhbhWITF0g5J7ce4CGweWk7xOZ5D8UGVqynUWQ6zCGzMqYGhABP7cOY/FHMSkQ6q4Hlk/coOAjJLkgxU64asfGMUJJlwOW3yRwfiv66t2qKXoYBWF35rMM8BJCTbAmXt/SAvEY+y8Qw1SiuErqEk6MS3sWHe0aX/k8/jReO8EAV1mHI3mrc0qGuf444Ofow== chief_ecs&quot;

# Key name as it will be stored in EC2
key_name=&quot;chief_ecs&quot;

# Name of ECS cluster
ecs_cluster_name=&quot;wercker-demo&quot;
</code></pre>
			<p>Next, let&#39;s use the <code>plan</code> terraform subcommand to make sure everything is kosher. I have included some <code>npm</code> scripts to simplify it:</p>
			<pre><code>$ npm run plan-ecs
</code></pre>
			<p>You should get a nice summary of what Terraform is planning on creating based on your <code>ecs.tfstate</code> file (which shouldn&#39;t exist yet):</p>
			<pre><code>Refreshing Terraform state prior to plan...


The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&#39;t specify an &quot;-out&quot; parameter to save this plan, so when
&quot;apply&quot; is called, Terraform can&#39;t guarantee this is what will execute.

+ aws_autoscaling_group.ecs
    availability_zones.#:          &quot;&quot; =&gt; &quot;3&quot;
    availability_zones.2762590996: &quot;&quot; =&gt; &quot;us-east-1d&quot;
    availability_zones.3569565595: &quot;&quot; =&gt; &quot;us-east-1a&quot;
    availability_zones.986537655:  &quot;&quot; =&gt; &quot;us-east-1c&quot;
    default_cooldown:              &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    desired_capacity:              &quot;&quot; =&gt; &quot;2&quot;
    force_delete:                  &quot;&quot; =&gt; &quot;0&quot;
    health_check_grace_period:     &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    health_check_type:             &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    launch_configuration:          &quot;&quot; =&gt; &quot;ecs&quot;
    max_size:                      &quot;&quot; =&gt; &quot;10&quot;
    min_size:                      &quot;&quot; =&gt; &quot;1&quot;
    name:                          &quot;&quot; =&gt; &quot;ecs-asg&quot;
    vpc_zone_identifier.#:         &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    wait_for_capacity_timeout:     &quot;&quot; =&gt; &quot;10m&quot;

+ aws_ecs_cluster.default
    name: &quot;&quot; =&gt; &quot;default&quot;

+ aws_iam_instance_profile.ecs
    arn:             &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    create_date:     &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    name:            &quot;&quot; =&gt; &quot;ecs-instance-profile&quot;
    path:            &quot;&quot; =&gt; &quot;/&quot;
    roles.#:         &quot;&quot; =&gt; &quot;1&quot;
    roles.112154061: &quot;&quot; =&gt; &quot;ecs_role&quot;
    unique_id:       &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;

+ aws_iam_role.ecs_role
    arn:                &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    assume_role_policy: &quot;&quot; =&gt; &quot;{\n  \&quot;Version\&quot;: \&quot;2008-10-17\&quot;,\n  \&quot;Statement\&quot;: [\n    {\n      \&quot;Action\&quot;: \&quot;sts:AssumeRole\&quot;,\n      \&quot;Principal\&quot;: {\n        \&quot;Service\&quot;: [\&quot;ecs.amazonaws.com\&quot;, \&quot;ec2.amazonaws.com\&quot;]\n      },\n      \&quot;Effect\&quot;: \&quot;Allow\&quot;\n    }\n  ]\n}\n&quot;
    name:               &quot;&quot; =&gt; &quot;ecs_role&quot;
    path:               &quot;&quot; =&gt; &quot;/&quot;
    unique_id:          &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;

+ aws_iam_role_policy.ecs_instance_role_policy
    name:   &quot;&quot; =&gt; &quot;ecs_instance_role_policy&quot;
    policy: &quot;&quot; =&gt; &quot;{\n  \&quot;Version\&quot;: \&quot;2012-10-17\&quot;,\n  \&quot;Statement\&quot;: [\n    {\n      \&quot;Effect\&quot;: \&quot;Allow\&quot;,\n      \&quot;Action\&quot;: [\n        \&quot;ecs:CreateCluster\&quot;,\n        \&quot;ecs:DeregisterContainerInstance\&quot;,\n        \&quot;ecs:DiscoverPollEndpoint\&quot;,\n        \&quot;ecs:Poll\&quot;,\n        \&quot;ecs:RegisterContainerInstance\&quot;,\n        \&quot;ecs:StartTelemetrySession\&quot;,\n        \&quot;ecs:Submit*\&quot;,\n        \&quot;ecs:StartTask\&quot;\n      ],\n      \&quot;Resource\&quot;: \&quot;*\&quot;\n    }\n  ]\n}\n&quot;
    role:   &quot;&quot; =&gt; &quot;${aws_iam_role.ecs_role.id}&quot;

+ aws_iam_role_policy.ecs_service_role_policy
    name:   &quot;&quot; =&gt; &quot;ecs_service_role_policy&quot;
    policy: &quot;&quot; =&gt; &quot;{\n  \&quot;Version\&quot;: \&quot;2012-10-17\&quot;,\n  \&quot;Statement\&quot;: [\n    {\n      \&quot;Effect\&quot;: \&quot;Allow\&quot;,\n      \&quot;Action\&quot;: [\n        \&quot;elasticloadbalancing:Describe*\&quot;,\n        \&quot;elasticloadbalancing:DeregisterInstancesFromLoadBalancer\&quot;,\n        \&quot;elasticloadbalancing:RegisterInstancesWithLoadBalancer\&quot;,\n        \&quot;ec2:Describe*\&quot;,\n        \&quot;ec2:AuthorizeSecurityGroupIngress\&quot;\n      ],\n      \&quot;Resource\&quot;: [\n        \&quot;*\&quot;\n      ]\n    }\n  ]\n}\n&quot;
    role:   &quot;&quot; =&gt; &quot;${aws_iam_role.ecs_role.id}&quot;

+ aws_key_pair.ecs
    fingerprint: &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    key_name:    &quot;&quot; =&gt; &quot;chief_ecs&quot;
    public_key:  &quot;&quot; =&gt; &quot;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAqtYxLvMCPCujceL9GeR7SHHtHODKh+WLt5jPXcaIAnXGO0OlQAaZEHIVlHvytxRvg/cgqS6r3i/pnz8thLrpLFjBdYW0LtMK1z2U8s3qXxszksf6McJj64khk4kjs7esWj6N6B1fziP4DL4KwjhoslcHyfhbhWITF0g5J7ce4CGweWk7xOZ5D8UGVqynUWQ6zCGzMqYGhABP7cOY/FHMSkQ6q4Hlk/coOAjJLkgxU6krQ8GMUJJlwOW3yRwfiv66t2qKXoYBWF35rMM8BJCTbAmXt/SAvEY+y8Qw1SiuErqEk6MS3sWHe0aX/k8/jReO8EAV1mHI3mrc0qGu5DZCOfow== chief_ecs&quot;

+ aws_launch_configuration.ecs
    associate_public_ip_address: &quot;&quot; =&gt; &quot;0&quot;
    ebs_block_device.#:          &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    ebs_optimized:               &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    enable_monitoring:           &quot;&quot; =&gt; &quot;1&quot;
    iam_instance_profile:        &quot;&quot; =&gt; &quot;ecs-instance-profile&quot;
    image_id:                    &quot;&quot; =&gt; &quot;ami-9886a0f2&quot;
    instance_type:               &quot;&quot; =&gt; &quot;t2.micro&quot;
    key_name:                    &quot;&quot; =&gt; &quot;chief_ecs&quot;
    name:                        &quot;&quot; =&gt; &quot;ecs&quot;
    root_block_device.#:         &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    security_groups.#:           &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    user_data:                   &quot;&quot; =&gt; &quot;cbde5513a6f551821684610116982ef8dda16445&quot;

+ aws_security_group.ecs
    description:                          &quot;&quot; =&gt; &quot;Container Instance Allowed Ports&quot;
    egress.#:                             &quot;&quot; =&gt; &quot;1&quot;
    egress.482069346.cidr_blocks.#:       &quot;&quot; =&gt; &quot;1&quot;
    egress.482069346.cidr_blocks.0:       &quot;&quot; =&gt; &quot;0.0.0.0/0&quot;
    egress.482069346.from_port:           &quot;&quot; =&gt; &quot;0&quot;
    egress.482069346.protocol:            &quot;&quot; =&gt; &quot;-1&quot;
    egress.482069346.security_groups.#:   &quot;&quot; =&gt; &quot;0&quot;
    egress.482069346.self:                &quot;&quot; =&gt; &quot;0&quot;
    egress.482069346.to_port:             &quot;&quot; =&gt; &quot;0&quot;
    ingress.#:                            &quot;&quot; =&gt; &quot;1&quot;
    ingress.1377569725.cidr_blocks.#:     &quot;&quot; =&gt; &quot;1&quot;
    ingress.1377569725.cidr_blocks.0:     &quot;&quot; =&gt; &quot;0.0.0.0/0&quot;
    ingress.1377569725.from_port:         &quot;&quot; =&gt; &quot;1&quot;
    ingress.1377569725.protocol:          &quot;&quot; =&gt; &quot;tcp&quot;
    ingress.1377569725.security_groups.#: &quot;&quot; =&gt; &quot;0&quot;
    ingress.1377569725.self:              &quot;&quot; =&gt; &quot;0&quot;
    ingress.1377569725.to_port:           &quot;&quot; =&gt; &quot;65535&quot;
    name:                                 &quot;&quot; =&gt; &quot;ecs-sg&quot;
    owner_id:                             &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    tags.#:                               &quot;&quot; =&gt; &quot;1&quot;
    tags.Name:                            &quot;&quot; =&gt; &quot;ecs-sg&quot;
    vpc_id:                               &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;

+ template_file.user_data
    rendered:             &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
    template:             &quot;&quot; =&gt; &quot;#!/bin/bash\n\nconfig_file=/etc/ecs/ecs.config\n\necho \&quot;ECS_CLUSTER=${cluster_name}\&quot; &gt; $config_file\necho \&quot;ECS_ENGINE_AUTH_TYPE=dockercfg\&quot; &gt;&gt; $config_file\necho \&quot;ECS_ENGINE_AUTH_DATA={\\\&quot;https://index.docker.io/v1/\\\&quot;:{\\\&quot;auth\\\&quot;:\\\&quot;${dockerhub_auth}\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;${dockerhub_email}\\\&quot;}}\&quot; &gt;&gt; $config_file\n&quot;
    vars.#:               &quot;&quot; =&gt; &quot;3&quot;
    vars.cluster_name:    &quot;&quot; =&gt; &quot;wercker-demo&quot;
    vars.dockerhub_auth:  &quot;&quot; =&gt; &quot;J032kdjfd$(sk$Jlkj==&quot;
    vars.dockerhub_email: &quot;&quot; =&gt; &quot;chief@beefdisciple.com&quot;


Plan: 10 to add, 0 to change, 0 to destroy.
</code></pre>
			<p>As you can see from the last line of output, Terraform is planning on creating 10 resources. Later if you need to modify any of your AWS infrastructure, you can
				change your templates, and once again <code>npm run ecs-plan</code> and <code>npm run ecs-apply</code> and Terraform will magically manage the changes for you.
				Next, apply the plan and actually create the infrastructure. You should only have to perform this once unless you plan on creating an ECS cluster per-environment
				(dev/stage/prod).</p>
			<pre><code>$ npm run apply-ecs
...
this will take 5-10 minutes
...

Apply complete! Resources: 10 added, 0 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: ../../ecs.tfstate
</code></pre>
			<p>You can check the status of your cluster using the <code>aws</code> cli:</p>
			<pre><code>❯ aws ecs describe-clusters --clusters wercker-demo --profile personal
{
    &quot;clusters&quot;: [
        {
            &quot;status&quot;: &quot;ACTIVE&quot;,
            &quot;clusterName&quot;: &quot;wercker-demo&quot;,
            &quot;registeredContainerInstancesCount&quot;: 2,
            &quot;pendingTasksCount&quot;: 0,
            &quot;runningTasksCount&quot;: 0,
            &quot;activeServicesCount&quot;: 0,
            &quot;clusterArn&quot;: &quot;arn:aws:ecs:us-east-1:1234456789:cluster/wercker-demo&quot;
        }
    ],
    &quot;failures&quot;: []
}
</code></pre>
			<p>There are two <code>registeredContainerInstancesCount</code> which is what was specified with our Terraform script, and the cluster is <code>ACTIVE</code> so
				everything looks good!</p>
			<h1 id="adding-the-ecs-deploy-target">Adding the ECS Deploy Target</h1>
			<p>Up until now, there has only been one deploy target, the <code>dockerhub</code> target which pushes the build artifact as a docker image to DockerHub and tags
				it with the commit hash. Now that the ECS cluster is ready for services, we can use a custom Wercker step in the <em>deploy</em> pipeline to run Terraform which
				will build out and deploy ECS services and tasks relating to the simple Seneca microservice we&#39;ve created.</p>
			<h2 id="add-a-new-deploy-target">Add A New Deploy Target</h2>
			<p>On the Wercker website, in the <code>wercker-node-ecs-demo</code> application settings, we&#39;ll need to add a new deploy target. The new target is simply called
				<code>ecs</code>, and it&#39;s important that we inject certain environment vars to the deploy. </p>
			<p>Use the settings cog to go into the application&#39;s settings, and then create a new deploy target <code>ecs</code>. Next, click &quot;Add new variable&quot;
				and enter the following: <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, and <code>AWS_DEFAULT_REGION</code>. These vars will be used by
				Terraform&#39;s AWS provisioner. </p>
			<p>These credentials must have <code>&quot;ecs:*&quot;</code>, <code>s3:*</code> and <code>ec2:elb:*</code> rights in order to create the AWS infrastructure required.
				I am using the built-in &quot;arn:aws:iam::aws:policy/PowerUserAccess&quot; which include </p>
			<p>Also add <code>AWS_ACCOUNT_ID</code> will be used to costruct some Terraform vars that our ECS templates need. </p>
			<div class="centered">
				<img src="/assets/img/wercker-ecs-demo-9.png" alt="add environment variables">
			</div>

			<h2 id="the-terraform-templates">The Terraform Templates</h2>
			<p>In order to deploy our service to ECS, we need a few simple Terraform templates along with some JSON to define the ECS tasks. </p>
			<pre><code>resource &quot;aws_ecs_service&quot; &quot;movie_api&quot; {
    depends_on = [&quot;aws_ecs_task_definition.movie_api&quot;]

    name = &quot;${concat(&quot;movie_api-&quot;,var.env)}&quot;
    cluster = &quot;${var.ecs_cluster_id}&quot;
    task_definition = &quot;${aws_ecs_task_definition.movie_api.arn}&quot;
    desired_count = 2
    iam_role = &quot;${var.iam_role_arn}&quot;

    load_balancer {
        elb_name = &quot;${aws_elb.movie_api_elb.id}&quot;
        container_name = &quot;movie-api&quot;
        container_port = 3000
    }
}

resource &quot;aws_ecs_task_definition&quot; &quot;movie_api&quot; {
    family = &quot;${concat(&quot;movie-api-&quot;,var.env)}&quot;
    container_definitions = &quot;${file(&quot;movie-api-task.json&quot;)}&quot;
}
</code></pre>
			<p>In ECS-land, a <code>service</code> consists of a <code>task-definition</code> which is a JSON-representation of orchestrated containers. ECS allows you to attach
				an ELB to a <code>service</code> along with specifying the number of task instances to spawn (this includes any containers in the task definition). For further
				details on ECS terminology and options, <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html">check the documentation</a>!</p>
			<p>There are two Terraform outputs from the ECS cluster template (at the very beginning of this post) that we must reference here: <code>${var.ecs_cluster_id}</code>,
				which is just the full ARN of the <code>wercker-demo</code> ECS cluster which was created in the previous step, and <code>${var.iam_role_arn}</code>, which is
				the IAM role also created in the previous step. These two values will be injected into Terraform by using environment variables set in a <code>wercker.yml</code>				step, which will be covered next.</p>
			<p>Here is the template for the ELB. There is nothing very special about this ELB other than the fact that it will listen on <code>http:80</code> and forward to
				our ECS cluster instances at <code>http:3000</code>. </p>
			<pre><code># Create a new load balancer
resource &quot;aws_elb&quot; &quot;movie_api_elb&quot; {
    name = &quot;${concat(&quot;movie-api-&quot;,var.env)}&quot;

    availability_zones = [&quot;us-east-1a&quot;, &quot;us-east-1c&quot;, &quot;us-east-1d&quot;]

    listener {
        instance_port = 3000
        instance_protocol = &quot;http&quot;
        lb_port = 80
        lb_protocol = &quot;http&quot;
    }

    health_check {
        healthy_threshold = 3
        unhealthy_threshold = 3
        timeout = 3
        target = &quot;tcp:3000&quot;
        interval = 30
    }

    cross_zone_load_balancing = true
    idle_timeout = 400
    connection_draining = true
    connection_draining_timeout = 400

    tags {
        Name = &quot;${concat(&quot;Movie API - &quot;,var.env)}&quot;
        Env = &quot;${var.env}&quot;
    }
}
</code></pre>
			<h3 id="ecs-task-definition-json">ECS Task Definition JSON</h3>
			<p>To orchestrate our movie service which utilizes redis, we will create an ECS task definition for it:</p>
			<pre><code class="lang-json">[
    {
        &quot;environment&quot;: [
            {
                &quot;name&quot;: &quot;NODE_ENV&quot;,
                &quot;value&quot;: &quot;production&quot;
            },
            {
                &quot;name&quot;: &quot;SVC_REDIS_HOST&quot;,
                &quot;value&quot;: &quot;redis&quot;
            }
        ],
        &quot;essential&quot;: true,
        &quot;image&quot;: &quot;chiefy/wercker-ecs-demo:${WERCKER_GIT_COMMIT}&quot;,
        &quot;logConfiguration&quot;: {
            &quot;logDriver&quot;: &quot;json-file&quot;
        },
        &quot;links&quot;: [
            &quot;redis&quot;
        ],
        &quot;memory&quot;: 128,
        &quot;cpu&quot;: 256,
        &quot;mountPoints&quot;: [],
        &quot;name&quot;: &quot;movie-api&quot;,
        &quot;portMappings&quot;: [
            {
                &quot;containerPort&quot;: 3000,
                &quot;hostPort&quot;: 3000,
                &quot;protocol&quot;: &quot;tcp&quot;
            }
        ]
    },
    {
        &quot;image&quot;: &quot;redis&quot;,
        &quot;name&quot;: &quot;redis&quot;,
        &quot;memory&quot;: 256,
        &quot;cpu&quot;: 256,
        &quot;essential&quot;: true,
        &quot;logConfiguration&quot;: {
            &quot;logDriver&quot;: &quot;json-file&quot;
        }
    }
]
</code></pre>
			<p>There are some important things to note here. In the first container definition, it&#39;s important to reference the docker image we built with wercker and pushed
				to DockerHub. Since it is tagged with the commit hash, we need to inject this value into the JSON somehow. Luckily there is a wercker step that can easily inject
				environment variables into a file: <code>appnific/expandenv@0.1.3</code>. This step will substitute the build hash for <code>${WERCKER_GIT_COMMIT}</code> before
				running Terraform. </p>
			<p>If you have used <code>docker-compose</code>, you are likely aware of how to link two containers together using <code>links</code>. For ECS, it is very similar,
				in the container definition for <code>movie-api</code> there is a property called <code>links</code> which references the container definition later defined
				for the <code>redis</code> instance. We can then use the hostname <code>redis</code> and use it by setting the <code>SVC_REDIS_HOST</code> environment variable
				in our service container&#39;s defintion.</p>
			<h2 id="update-wercker-yml-with-new-deploy-target">Update <code>wercker.yml</code> With New Deploy Target</h2>
			<p>Now that the Terraform template has been created that will deploy our microservice and redis to ECS, it&#39;s time to update the <code>wercker.yml</code> to reference
				our new deploy target.</p>
			<pre><code>...
deploy:

  box: nodesource/trusty:4.3.0

  ecs:
    - script:
        name: set ENV vars
        code: |
          export TF_VAR_iam_role_arn=arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecs_role
          export TF_VAR_ecs_cluster_id=arn:aws:ecs:us-east-1:${AWS_ACCOUNT_ID}:cluster/wercker-demo

    - appnific/expandenv@0.1.3:
        input_file: movie-api-task-template.json
        output_file: movie-api-task.json

    - releasequeue/run-terraform@0.0.17:
        action: apply
        state_stor_bucket: tf_state_bucket
        state_stor_bucket_region: us-east-1
        state_stor_key: movie_api_ecs
</code></pre>
			<p>The first step of the <code>ecs</code> deploy sets some environment vars that Terraform will need to complete. Note that these must be prefixed with <code>TF_VAR_</code>.
				Next, as has been explained above, we inject the commit hash of the build into the ECS task definition JSON and output a new JSON file by using the <code>appnific/expandenv</code>				step. Finally the Terraform step will install and apply templates also storing the <code>.tfstate</code> file in the s3 bucket <code>tf_state_bucket</code> with
				the key <code>movie_api_ecs</code>.</p>
			<p>Since <code>releasequeue/run-terraform</code> will try to pull and install Terraform, we must use a custom <code>box</code> in our deploy step with a few more
				built-in tools than the Alpine based image. In this instance, <code>nodesource/trusty:4.3.0</code> will work just fine.</p>
			<p>There is one last tweak that needs to be made. In order to have the <code>releasequeue/run-terraform</code> step run, the ECS task Terraform template files need
				to be copied to the root of our build&#39;s output directory. This can be accomplished by adding one more line to the last step of our <em>build</em> pipeline
				where files are copied to <code>$WERCKER_OUTPUT_DIR</code>.</p>
			<pre><code>...
    - script:
        name: copy files
        code: |
          cp $(which node) &quot;$WERCKER_OUTPUT_DIR&quot;
          cp -RL node_modules config data api index.js package.json &quot;$WERCKER_OUTPUT_DIR&quot;
          cp terraform/*.tf terraform/*.json &quot;$WERCKER_OUTPUT_DIR&quot;
...
</code></pre>
			<h1 id="the-moment-of-truth">The Moment of Truth</h1>
			<p>Once then new Terraform templates and <code>wercker.yml</code> modifications have been pushed, and a new build is succesfully pushed to DockerHub, we can try
				out the deploy to ECS on wercker&#39;s site.</p>
			<div class="centered">
				<img src="/assets/img/wercker-ecs-demo-10.png" alt="run ecs deploy target">
			</div>

			<pre><code>Initialized blank state with remote state enabled!
Remote state configured and pulled.
aws_ecs_task_definition.movie_api: Creating...
  arn:                   &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  container_definitions: &quot;&quot; =&gt; &quot;d424e20a71795b57c92918a63be4e64a616d1294&quot;
  family:                &quot;&quot; =&gt; &quot;movie-api-production&quot;
  revision:              &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
aws_elb.movie_api_elb: Creating...
  availability_zones.#:                       &quot;&quot; =&gt; &quot;3&quot;
  availability_zones.1532376300:              &quot;&quot; =&gt; &quot;us-east-1d&quot;
  availability_zones.725401701:               &quot;&quot; =&gt; &quot;us-east-1a&quot;
  availability_zones.986537655:               &quot;&quot; =&gt; &quot;us-east-1c&quot;
  connection_draining:                        &quot;&quot; =&gt; &quot;1&quot;
  connection_draining_timeout:                &quot;&quot; =&gt; &quot;400&quot;
  cross_zone_load_balancing:                  &quot;&quot; =&gt; &quot;1&quot;
  dns_name:                                   &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  health_check.#:                             &quot;&quot; =&gt; &quot;1&quot;
  health_check.434606976.healthy_threshold:   &quot;&quot; =&gt; &quot;3&quot;
  health_check.434606976.interval:            &quot;&quot; =&gt; &quot;30&quot;
  health_check.434606976.target:              &quot;&quot; =&gt; &quot;HTTP:3000/&quot;
  health_check.434606976.timeout:             &quot;&quot; =&gt; &quot;3&quot;
  health_check.434606976.unhealthy_threshold: &quot;&quot; =&gt; &quot;3&quot;
  idle_timeout:                               &quot;&quot; =&gt; &quot;400&quot;
  instances.#:                                &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  internal:                                   &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  listener.#:                                 &quot;&quot; =&gt; &quot;1&quot;
  listener.1497737023.instance_port:          &quot;&quot; =&gt; &quot;3000&quot;
  listener.1497737023.instance_protocol:      &quot;&quot; =&gt; &quot;http&quot;
  listener.1497737023.lb_port:                &quot;&quot; =&gt; &quot;80&quot;
  listener.1497737023.lb_protocol:            &quot;&quot; =&gt; &quot;http&quot;
  listener.1497737023.ssl_certificate_id:     &quot;&quot; =&gt; &quot;&quot;
  name:                                       &quot;&quot; =&gt; &quot;movie-api-production&quot;
  security_groups.#:                          &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  source_security_group:                      &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  source_security_group_id:                   &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  subnets.#:                                  &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
  tags.#:                                     &quot;&quot; =&gt; &quot;2&quot;
  tags.Env:                                   &quot;&quot; =&gt; &quot;production&quot;
  tags.Name:                                  &quot;&quot; =&gt; &quot;Movie API - production&quot;
  zone_id:                                    &quot;&quot; =&gt; &quot;&lt;computed&gt;&quot;
aws_ecs_task_definition.movie_api: Creation complete
aws_elb.movie_api_elb: Creation complete
aws_ecs_service.movie_api: Creating...
  cluster:                                 &quot;&quot; =&gt; &quot;arn:aws:ecs:us-east-1:710390882138:cluster/wercker-demo&quot;
  desired_count:                           &quot;&quot; =&gt; &quot;2&quot;
  iam_role:                                &quot;&quot; =&gt; &quot;arn:aws:iam::710390882138:role/ecs_role&quot;
  load_balancer.#:                         &quot;&quot; =&gt; &quot;1&quot;
  load_balancer.1255725728.container_name: &quot;&quot; =&gt; &quot;movie-api&quot;
  load_balancer.1255725728.container_port: &quot;&quot; =&gt; &quot;3000&quot;
  load_balancer.1255725728.elb_name:       &quot;&quot; =&gt; &quot;movie-api-production&quot;
  name:                                    &quot;&quot; =&gt; &quot;movie_api-production&quot;
  task_definition:                         &quot;&quot; =&gt; &quot;arn:aws:ecs:us-east-1:12340394059:task-definition/movie-api-production:1&quot;
aws_ecs_service.movie_api: Creation complete

Apply complete! Resources: 3 added, 0 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: .terraform/terraform.tfstate
State successfully pushed!
</code></pre>
			<div class="centered">
				<img src="http://i.giphy.com/aWRWTF27ilPzy.gif" alt="success">
			</div>

			<p>Now to try out the service, we need our ELB&#39;s host name:</p>
			<pre><code>❯ aws elb describe-load-balancers --load-balancer-name movie-api-production --profile personal | grep DNSName
&quot;DNSName&quot;: &quot;movie-api-production-482728403.us-east-1.elb.amazonaws.com&quot;,
</code></pre><pre><code>❯ curl -XGET http://movie-api-production-482728403.us-east-1.elb.amazonaws.com/Blue%20Velvet
{&quot;entity$&quot;:&quot;-/-/movie&quot;,&quot;title&quot;:&quot;Blue Velvet&quot;,&quot;year&quot;:1989,&quot;director&quot;:&quot;David Lynch&quot;,&quot;id&quot;:&quot;53d7857c-4cbf-4125-9ce8-59dc86f9160a&quot;}
</code></pre>
			<div class="centered">
				<img src="http://i.giphy.com/msKNSs8rmJ5m.gif" alt="yes">
			</div>

			<h1 id="in-summation">In Summation</h1>
			<p>Over the three parts of this blog post, I&#39;ve looked at how to use <a href="https://wercker.com">Wercker</a> in conjuction with <a href="https://www.terraform.io/">Hashicorp&#39;s Terraform</a>				as a complete CI/CD solution for building and deploying a <a href="senecajs.org">SenecaJS</a> microservice to <a href="https://aws.amazon.com/ecs/">Amazon ECS</a>.
				Terraform makes creating and provisioning AWS infrastructure a breeze. And with it&#39;s powerful pipeline concept and composable steps, Wercker has made it
				relatively easy to manage your microservice&#39;s build &amp; deploy process. With these tools we can create slim and simple Seneca microservices container images
				which are continiously deployed. I hope these posts are helpful to anyone trying to get into using these wonderful tools to simplify developer&#39;s lives.</p>
			<ul>
				<li><a href="https://github.com/chiefy/wercker-node-ecs-demo">Wercker-ECS-Seneca Demo Project Source</a></li>
				<li><a href="https://app.wercker.com/#applications/56ca181c7beb00ce4022f8cc">Application on Wercker</a></li>
			</ul>

			<div class="divider"></div>
			<ul class="rrssb-buttons">
				<li class="rrssb-hackernews">
					<a href="">
						<span class="rrssb-icon">
				<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28">
					<path fill="#FFF" d="M14 13.626l-4.508-9.19H6.588l6.165 12.208v6.92h2.51v-6.92l6.15-12.21H18.69" />
				</svg>
			</span>
						<span class="rrssb-text">hackernews</span>
					</a>
				</li>
				<li class="rrssb-linkedin">
					<!-- Replace href with your meta and URL information -->
					<a href="" class="popup">
						<span class="rrssb-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28"><path d="M25.424 15.887v8.447h-4.896v-7.882c0-1.98-.71-3.33-2.48-3.33-1.354 0-2.158.91-2.514 1.802-.13.315-.162.753-.162 1.194v8.216h-4.9s.067-13.35 0-14.73h4.9v2.087c-.01.017-.023.033-.033.05h.032v-.05c.65-1.002 1.812-2.435 4.414-2.435 3.222 0 5.638 2.106 5.638 6.632zM5.348 2.5c-1.676 0-2.772 1.093-2.772 2.54 0 1.42 1.066 2.538 2.717 2.546h.032c1.71 0 2.77-1.132 2.77-2.546C8.056 3.593 7.02 2.5 5.344 2.5h.005zm-2.48 21.834h4.896V9.604H2.867v14.73z"/></svg></span>
						<span class="rrssb-text">linkedin</span>
					</a>
				</li>
				<li class="rrssb-twitter">
					<!-- Replace href with your Meta and URL information  -->
					<a href="" class="popup">
						<span class="rrssb-icon">
				<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28">
					<path d="M24.253 8.756C24.69 17.08 18.297 24.182 9.97 24.62c-3.122.162-6.22-.646-8.86-2.32 2.702.18 5.375-.648 7.507-2.32-2.072-.248-3.818-1.662-4.49-3.64.802.13 1.62.077 2.4-.154-2.482-.466-4.312-2.586-4.412-5.11.688.276 1.426.408 2.168.387-2.135-1.65-2.73-4.62-1.394-6.965C5.574 7.816 9.54 9.84 13.802 10.07c-.842-2.738.694-5.64 3.434-6.48 2.018-.624 4.212.043 5.546 1.682 1.186-.213 2.318-.662 3.33-1.317-.386 1.256-1.248 2.312-2.4 2.942 1.048-.106 2.07-.394 3.02-.85-.458 1.182-1.343 2.15-2.48 2.71z"
					/>
				</svg>
			</span>
						<span class="rrssb-text">twitter</span>
					</a>
				</li>
				<li class="rrssb-reddit">
					<a href="">
						<span class="rrssb-icon">
				<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28">
					<path d="M11.794 15.316c0-1.03-.835-1.895-1.866-1.895-1.03 0-1.893.866-1.893 1.896s.863 1.9 1.9 1.9c1.023-.016 1.865-.916 1.865-1.9zM18.1 13.422c-1.03 0-1.895.864-1.895 1.895 0 1 .9 1.9 1.9 1.865 1.03 0 1.87-.836 1.87-1.865-.006-1.017-.875-1.917-1.875-1.895zM17.527 19.79c-.678.68-1.826 1.007-3.514 1.007h-.03c-1.686 0-2.834-.328-3.51-1.005-.264-.265-.693-.265-.958 0-.264.265-.264.7 0 1 .943.9 2.4 1.4 4.5 1.402.005 0 0 0 0 0 .005 0 0 0 0 0 2.066 0 3.527-.46 4.47-1.402.265-.264.265-.693.002-.958-.267-.334-.688-.334-.988-.043z"
					/>
					<path d="M27.707 13.267c0-1.785-1.453-3.237-3.236-3.237-.792 0-1.517.287-2.08.76-2.04-1.294-4.647-2.068-7.44-2.218l1.484-4.69 4.062.955c.07 1.4 1.3 2.6 2.7 2.555 1.488 0 2.695-1.208 2.695-2.695C25.88 3.2 24.7 2 23.2 2c-1.06 0-1.98.616-2.42 1.508l-4.633-1.09c-.344-.082-.693.117-.803.454l-1.793 5.7C10.55 8.6 7.7 9.4 5.6 10.75c-.594-.45-1.3-.75-2.1-.72-1.785 0-3.237 1.45-3.237 3.2 0 1.1.6 2.1 1.4 2.69-.04.27-.06.55-.06.83 0 2.3 1.3 4.4 3.7 5.9 2.298 1.5 5.3 2.3 8.6 2.325 3.227 0 6.27-.825 8.57-2.325 2.387-1.56 3.7-3.66 3.7-5.917 0-.26-.016-.514-.05-.768.965-.465 1.577-1.565 1.577-2.698zm-4.52-9.912c.74 0 1.3.6 1.3 1.3 0 .738-.6 1.34-1.34 1.34s-1.343-.602-1.343-1.34c.04-.655.596-1.255 1.396-1.3zM1.646 13.3c0-1.038.845-1.882 1.883-1.882.31 0 .6.1.9.21-1.05.867-1.813 1.86-2.26 2.9-.338-.328-.57-.728-.57-1.26zm20.126 8.27c-2.082 1.357-4.863 2.105-7.83 2.105-2.968 0-5.748-.748-7.83-2.105-1.99-1.3-3.087-3-3.087-4.782 0-1.784 1.097-3.484 3.088-4.784 2.08-1.358 4.86-2.106 7.828-2.106 2.967 0 5.7.7 7.8 2.106 1.99 1.3 3.1 3 3.1 4.784C24.86 18.6 23.8 20.3 21.8 21.57zm4.014-6.97c-.432-1.084-1.19-2.095-2.244-2.977.273-.156.59-.245.928-.245 1.036 0 1.9.8 1.9 1.9-.016.522-.27 1.022-.57 1.327z"
					/>
				</svg>
			</span>
						<span class="rrssb-text">reddit</span>
					</a>
				</li>
				<li class="rrssb-googleplus">
					<a href="" class="popup">
						<span class="rrssb-icon">
				<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M21 8.29h-1.95v2.6h-2.6v1.82h2.6v2.6H21v-2.6h2.6v-1.885H21V8.29zM7.614 10.306v2.925h3.9c-.26 1.69-1.755 2.925-3.9 2.925-2.34 0-4.29-2.016-4.29-4.354s1.885-4.353 4.29-4.353c1.104 0 2.014.326 2.794 1.105l2.08-2.08c-1.3-1.17-2.924-1.883-4.874-1.883C3.65 4.586.4 7.835.4 11.8s3.25 7.212 7.214 7.212c4.224 0 6.953-2.988 6.953-7.082 0-.52-.065-1.104-.13-1.624H7.614z"/></svg>            </span>
						<span class="rrssb-text">google+</span>
					</a>
				</li>
				<li class="rrssb-email">
					<a href="">
						<span class="rrssb-icon"><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path d="M20.11 26.147c-2.335 1.05-4.36 1.4-7.124 1.4C6.524 27.548.84 22.916.84 15.284.84 7.343 6.602.45 15.4.45c6.854 0 11.8 4.7 11.8 11.252 0 5.684-3.193 9.265-7.398 9.3-1.83 0-3.153-.934-3.347-2.997h-.077c-1.208 1.986-2.96 2.997-5.023 2.997-2.532 0-4.36-1.868-4.36-5.062 0-4.75 3.503-9.07 9.11-9.07 1.713 0 3.7.4 4.6.972l-1.17 7.203c-.387 2.298-.115 3.3 1 3.4 1.674 0 3.774-2.102 3.774-6.58 0-5.06-3.27-8.994-9.304-8.994C9.05 2.87 3.83 7.545 3.83 14.97c0 6.5 4.2 10.2 10 10.202 1.987 0 4.09-.43 5.647-1.245l.634 2.22zM16.647 10.1c-.31-.078-.7-.155-1.207-.155-2.572 0-4.596 2.53-4.596 5.53 0 1.5.7 2.4 1.9 2.4 1.44 0 2.96-1.83 3.31-4.088l.592-3.72z"/></svg></span>
						<span class="rrssb-text">email</span>
					</a>
				</li>
			</ul>

			<div id="disqus_thread"></div>
			<script>
				var disqus_config = function() {
					this.page.url = 'https://chiefy.github.ioeasily-deploy-a-seneca-microservice-to-ecs-with-wercker-and-terraform-part-iii';
					this.page.identifier = 'Easily-Deploy-A-Seneca-Microservice-to-ECS-with-Wercker-and-Terraform-Part-III';
				};
				(function() { // DON'T EDIT BELOW THIS LINE
					var d = document,
						s = d.createElement('script');
					s.src = '//chiefy.disqus.com/embed.js';
					s.setAttribute('data-timestamp', +new Date());
					(d.head || d.body).appendChild(s);
				})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

		</article>
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
		<script>
			hljs.initHighlightingOnLoad();
		</script>
		<script>
			window.jQuery || document.write('<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"><\/script>')
		</script>
		<script src="/assets/js/rrssb.min.js"></script>
		<script type="text/javascript">
			$(document).ready(function() {
				$('.rrssb-buttons').rrssb({
					title: 'Easily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III',
					url: 'https://chiefy.github.io/easily-deploy-a-seneca-microservice-to-ecs-with-wercker-and-terraform-part-iii',
					description: 'Easily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III via @tehsuck',
					emailBody: '\nEasily Deploy A Seneca Microservice to ECS with Wercker and Terraform Part III\nhttps://chiefy.github.io/easily-deploy-a-seneca-microservice-to-ecs-with-wercker-and-terraform-part-iii\n\nAmong the many players in the continious integration SaaS providers, I recently discovered Wercker:'
				});
			});
		</script>
		<div class="back">
			<a href="https://chiefy.github.io">back</a>
		</div>

	</main>
</body>

</html>